# frozen_string_literal: true

class CourseDetailForm
  include ActiveModel::Model
  include ActiveModel::AttributeAssignment
  include ActiveModel::Validations::Callbacks
  extend CourseDetailsHelper

  attr_accessor :trainee, :subject, :subject_raw, :main_age_range,
                :additional_age_range, :additional_age_range_raw,
                :start_day, :start_month, :start_year,
                :end_day, :end_month, :end_year

  delegate :id, :persisted?, to: :trainee

  before_validation :sanitise_course_dates

  validates_inclusion_of :subject_raw, in: course_subjects
  validates :subject, presence: true
  validates_inclusion_of :additional_age_range_raw, in: age_ranges(option: :additional), if: -> { main_age_range&.to_sym == :other }
  validate :age_range_valid
  validate :course_start_date_valid
  validate :course_end_date_valid

  after_validation :update_trainee, :reassign_autocomplete_errors

  MAX_END_YEARS = 4

  def initialize(trainee)
    @trainee = trainee

    super(fields)
  end

  def fields
    attributes = {
      subject: trainee.subject,
      start_day: trainee.course_start_date&.day,
      start_month: trainee.course_start_date&.month,
      start_year: trainee.course_start_date&.year,
      end_day: trainee.course_end_date&.day,
      end_month: trainee.course_end_date&.month,
      end_year: trainee.course_end_date&.year,
    }

    age_range = Dttp::CodeSets::AgeRanges::MAPPING[trainee.age_range]

    if age_range.present?
      attributes["#{age_range[:option]}_age_range".to_sym] = trainee.age_range
      attributes[:main_age_range] = :other if age_range[:option] == :additional
    end

    attributes
  end

  def course_start_date
    new_date({ year: start_year, month: start_month, day: start_day })
  end

  def course_end_date
    new_date({ year: end_year, month: end_month, day: end_day })
  end

  def sanitise_course_dates
    course_dates = %w[start_day
                      start_month
                      start_year
                      end_day
                      end_month
                      end_year]

    return if course_dates.any?(&:nil?)

    course_dates.each do |date_attribute|
      date = "#{date_attribute}="
      sanitised_date = public_send(date_attribute).to_s.gsub(/\s+/, "")
      public_send(date, sanitised_date)
    end
  end

private

  def update_trainee
    if errors.empty?
      trainee.assign_attributes({
        subject: subject,
        age_range: age_range,
        course_start_date: course_start_date,
        course_end_date: course_end_date,
      })
    end
  end

  def reassign_autocomplete_errors
    # This is pretty messy.
    #
    # We need to reassign the errors from the text field for the autocompletes onto the select so that the error summary
    # links will work correctly - otherwise the link goes nowhere as the text input is not generated by the form builder, so
    # doesn't have the correct ID. We also need to move these errors ahead of any other errors so that they have higher
    # precedence when being rendered in the summary.

   if errors.messages[:subject_raw].present?
     errors.messages[:subject] = errors.messages.delete(:subject_raw) + errors.messages[:subject]
   end

   if errors.messages[:additional_age_range_raw].present?
     errors.messages[:additional_age_range] = errors.messages.delete(:additional_age_range_raw) + errors.messages[:additional_age_range]
   end

   # If we want to preserve the error message order in the summary, we need to redefine all the existing messages
   # as they are stored in the order they are added to the errors hash
   errors.messages.keys.excluding(:subject, :additional_age_range).each do |key|
     errors.messages[key] = errors.messages.delete(key)
   end
  end

  def new_date(date_hash)
    date_args = date_hash.values.map(&:to_i)
    Date.valid_date?(*date_args) ? Date.new(*date_args) : OpenStruct.new(date_hash)
  end

  def age_range
    return additional_age_range if main_age_range.to_sym == :other

    main_age_range
  end

  def age_range_valid
    if main_age_range.blank?
      errors.add(:main_age_range, :blank)
    elsif main_age_range.to_sym == :other && additional_age_range.blank?
      errors.add(:additional_age_range, :blank)
    end
  end

  def course_start_date_valid
    if [start_day, start_month, start_year].all?(&:blank?)
      errors.add(:course_start_date, :blank)
    elsif start_year.to_i > next_year
      errors.add(:course_start_date, :future)
    elsif !course_start_date.is_a?(Date)
      errors.add(:course_start_date, :invalid)
    elsif course_start_date < 10.years.ago
      errors.add(:course_start_date, :too_old)
    end
  end

  def course_end_date_valid
    if [end_day, end_month, end_year].all?(&:blank?)
      errors.add(:course_end_date, :blank)
    elsif end_year.to_i > max_years
      errors.add(:course_end_date, :future)
    elsif !course_end_date.is_a?(Date)
      errors.add(:course_end_date, :invalid)
    elsif course_end_date < 10.years.ago
      errors.add(:course_end_date, :too_old)
    end

    additional_validation = errors.attribute_names.none? do |attribute_name|
      %i[course_start_date course_end_date].include?(attribute_name)
    end

    if additional_validation && course_start_date >= course_end_date
      errors.add(:course_end_date, :before_or_same_as_start_date)
    end
  end

  def next_year
    Time.zone.now.year.next
  end

  def max_years
    next_year + MAX_END_YEARS
  end
end
